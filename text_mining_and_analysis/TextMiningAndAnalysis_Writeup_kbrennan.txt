Kelly Brennan
Software Design Spring 2015 â€“ Section I
Processor Paul Ruvolo and Ben Hill
February 26th, 2015

Project Overview:
	The implicit contradictions and uncertainties expressed through complex language with multiple interpretations yeilds the merit of Shakespearean sonnets. The sonnet's expressions of thought and emotion resonate with matters that concern all humans: love, friendship, jealously, hope and despair (Enotes). Sonnets are written in iambic pentameter, have fourteen lines, follow a set rhyme scheme, and have a turn or 'volta' (Poetic Form: Sonnet).  In a Shakepearean sonnet, three quatrains and a couplet follow the rhyming pattern: abab, cdcd, efef, gg, where the concluding couplet surprises the audience by it's contradicting, stimulating content. Due to the intricate, complicated linguistic qualities of sonnets, the python sonnet generator aims to incorporate a rhyming scheme in randomly producing two lines using Markov analysis. The python script SonnetGenerator.py composes the last two lines of a possible Shakespearean sonnet (gg). The code provides the framework for generating a full Shakespearean sonnet with a greater text input and improvements in computational efficiency. 

Implementation: 
	There are three main sections of the code are text processing, rhyme recognition and dictionary creation, and sonnet generation. First, one or multiple of Shakespeare's sonnets from the Project Gutenberg library are extracted. In the example code, I use only one of Shakespeare's sonnets due to running time constraints (described below). Each line of the text is used to generate a list containing only the last word of each line, which is lowercase and stripped of all punctuation ('last_word' list), and a list of lines without the last word. This setup allows the these last words to be compared to generate rhyming families and later joined with possible lines to form complete sonnet lines. 
	The second section has two parts, rhyme recognition and rhyming dictionary creation. I used the Natural Learning toolkit to recognize rhymes in the 'last_word' list. The 'rhyme' function analyzes the phoneme of the words for rhyming characteristics and the 'doTheyRhyme' function determines whether or not two input words rhyme. The output of 'doTheyRhyme' determines the rhyming dictionary that is created, where each key contains the word without a rhyme or a rhyming family, a list of rhyming words. The formation of the dictionary is heavily dependent on the code correctly identifying a rhyming relationships between words. The disadvantage of this rhyme identification approach is that code running time is very long for it to loop through the 'last_word' list and the dictionary keys, as well as compute if the words rhyme. However, the dictionary setup is easy to read and understand compared to a bunch of nested lists, because each key is a word and the value of each key includes the key and all the other words that rhyme with the key to create a rhyming family.  This allows the rhyming family, values that contains a list of rhyming words, to be in one place and easily accessed. 
	The third section uses the generated rhyming dictionary to compile a couple lines of a sonnet. A random line beginning joins a randomly chosen word. The code makes sure that the same two lines and rhyming words are not chosen. The code includes the rhyming pattern (gg) to compiles the last two sonnet lines.

Results: 

	A key limitation is that the rhyme recognition portion of the code misses many of Shakespeare's rhymes. On one hand, this is surprising because the output of the 'rhyme' function is very long list of words that rhyme with the input word. However, this failure demonstrates the complexity of rhyming, especially for a computer, because there are many different types of rhymes (perfect, general, identical, eye, mind, etc.). Additionally, the word differences between Shakespeare's early modern English language and modern language probably contributes to this error since the nltk is in modern English. The failure to recognize different types of rhymes propagates in to the rhyming dictionary formation, which is critical for sonnet generation. Therefore, the limitation in recognizing rhymes significantly constrains the sonnet generation output and overall success of the code. It is essential that future project work addresses this issue by increasing the rhyming recognition relationships. 
	I ran the example code for one Shakespearean sonnet from Project Gutenberg, because of the computation and running time issue. The runtime problem can be addressed by reducing for loops and implementing more advanced coding strategies to increase computational efficiency, indicating another important area of future work. Despite the long runtime, only one or two of my keys contained at a rhyming family containing a list of more than one word  due to the rhyming recognition constrain. With  about rhyming family per sonnet, it is only possible to form two randomly generated rhyming sonnet lines as items in a list, which is successful: 

		Calls back the lovely April of her tomb
		But if thou live, remember'd not to womb

		Look in thy glass and tell the face thou husbandry
		Now is the time that face should form posterity

		But if thou live, remember'd not to womb
		Disdains the tillage of thy tomb

Reflection:
	Considering that this was my first time designing a software program by figuring-out my project direction, as well as build and nest various functions into a functioning program, my over-scoped project process was weak in the overall outcome, but successful in the personal and learning domain For example, I discovered that I enjoyed working on my project during SLAC because of the abundant help and productive work environment, so I will plan to attend future SLAC events when possible. Working with NINJAS throughout the week helped me talk about my code out loud, find errors and improve computational efficiency, to the extent given. Additionally, I found that drafting functions diagrams was helpful in structuring my code in the design process. 
	Even though the design was probably slightly too ambitious for a 'mini-project', my project successfully establishes a framework to expand and create a sonnet of fourteen lines that follows Shakespeare's rhyming pattern with a larger volume of text input. My sonnet generating program was more complex than I anticipated, as I struggled with rhyming errors, computational with efficiency, and running time. With more time, I would figure out how to improve the accuracy of the rhyming recognition section and improve the computational efficiency. These problems have stimulated my interested in ways to increase computational efficiency. With the work that I have put into my project, I believe I have gained good practice with text mining and analysis techniques by accessing and importing outside text, exploring and implementing different python dictionaries (nltk),  formating the text for processing, creating a dictionary of rhyming families, and using the dictionary for the generation of a quasi-sonnet.  

Works Cited:
http://denny518.blogspot.com/2014/02/writing-sonnets-by-python.html 
http://www.poets.org/poetsorg/text/poetic-form-sonnet 
http://www.enotes.com/topics/shakespeare-sonnets 
